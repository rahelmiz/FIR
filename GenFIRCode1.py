#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Wed Feb  9 13:18:45 2022

@author: rahelmizrahi
"""
import pprint as pp
def _genVar(varName, numVars, enumFormat = None):
    # example call: Acc = _genVar("acc", 166, "A"); 
    #               Tap = _genVar("tap", 168)
    if enumFormat == None:
        varNames = []
        for i in range(0,numVars):
            varNames.append("{}{}".format(varName, i))
        return varNames
    if enumFormat== "A":
        varNames = []
        varNames.append("acc01")
        varNames.append("acc012")
        for i in range(2,numVars-2):
            varNames.append("{}{}_{}".format(varName, i, i+1))
        return varNames

class GenFIRCode:
    def __init__(self, numTaps, coeffsFile , outFile , bitWidth = None):
        #coeffsFile is the path to .txt file of the coefficient values generated by matlab
        self.coeffsFile = coeffsFile
        self.outFile = outFile
        self.numTaps = numTaps
        self.varNames = ["acc", "tap", "buff"]
        self.Adders = _genVar("acc", numTaps, "A")
        self.Accums = _genVar("acc", numTaps )
        self.Taps = _genVar("tap", numTaps)
        self.Buffs = _genVar("buff", numTaps)
        
        self.coeffs = self._getCoeffs() #the tap values
        if bitWidth == None:
            self.bitWidth = 16
        else: 
            self.bitWidth= bitWidth
        self.writeDeclarations()
        self.writeAssignTaps()
        self.writeMultAccumCode()
        
        
       


    def _getCoeffs(self):
        with open(self.coeffsFile, "r") as f: #was lazy and hardcded a path
            coeffs = f.readlines() #produces list of lines
        return coeffs
    
    def writeAssignTaps(self):
        with open(self.outFile, "a+") as f: 
            f.write("________________ tap assignments ________________\n")
            for i in range(0,self.numTaps):
                c = self.coeffs[i].strip()
                text = "assign tap{} = {}'h{};\n".format(i,self.bitWidth, c) #the squiglies are analogies to %type
                #for each squiggly, you need an item inside .format( ). 
                f.write(text)  
            f.write("________________ end tap assignments ________________\n")
            f.write("\n")
                
    def genDeclaration(self, netType, bitWidth, varName, numVars, enumFormat= None, signed = True):
        #returns a string of the form 
        #reg [bitWidth:0] varNames[0], ..., varNames[n]
        varNames = _genVar(varName, numVars, enumFormat)
        if signed == False:
            s= "{} [{}:0] ".format(netType, bitWidth-1)
        else:
            s = "{} signed [{}:0] ".format(netType, bitWidth-1)
        for idx, val in enumerate(varNames):
            if idx== len(varNames) - 1:
                s+= (val + ";")
            else:
                s+= (val + ", ")
        return s

    def genMultAccumStage(self):
        code = "";
        code += "buff0 <= s_axis_fir_tdata;\nacc0 <= tap0 * buff0;\n"
        code += "\n"
        
        i = 1
        code+="{} <= {};\n".format(self.Buffs[i], self.Buffs[i-1])
        code+="{} <= {} * {};\n".format(self.Accums[i], self.Taps[i], self.Buffs[i])
        code+="{} <= {} + {};\n".format(self.Adders[i-1], self.Accums[i-1], self.Accums[i])
        code += "\n"
        for i in range(2, self.numTaps):
            print(i)
            if i == self.numTaps - 2:
                print("i=13")
            if i == self.numTaps-1:
                code+="{} <= {};\n".format(self.Buffs[i], self.Buffs[i-1])
                code+="{} <= {} * {};\n".format(self.Accums[i], self.Taps[i], self.Buffs[i])
                code+="m_axis_fir_tdata <= {} + {};\n".format(self.Adders[i-2], self.Accums[i])
                break
            code+="{} <= {};\n".format(self.Buffs[i], self.Buffs[i-1])
            code+="{} <= {} * {};\n".format(self.Accums[i], self.Taps[i], self.Buffs[i])
            code+="{} <= {} + {};\n".format(self.Adders[i-1], self.Adders[i-2], self.Accums[i])
            code += "\n"
        return code
     
    def writeMultAccumCode(self, outPath = None):
        code = self.genMultAccumStage()
        with open(self.outFile, "a+") as f:
            f.write("________________ multiply accumulate stage ________________\n")
            f.write(code)
            f.write("________________ end multiply accumulate stage ________________\n")
            f.write("\n")
    
    def writeDeclarations(self):
        
        code = self.genDeclaration("reg", self.bitWidth , "buff", self.numTaps)  + "\n\n"
        code += self.genDeclaration("wire", self.bitWidth , "tap", self.numTaps) + "\n\n"
        code += self.genDeclaration("reg", (self.bitWidth*2) , "acc", self.numTaps) + "\n\n"
        code += self.genDeclaration("reg", (self.bitWidth*2) , "acc", self.numTaps, enumFormat= "A")+ "\n"
        with open(self.outFile, "w+") as f:
            f.write("________________ variable declarations ________________\n")
            f.write(code)
            f.write("________________ end variable declarations ________________\n")
            f.write("\n")
    def genTestBench(self, inPath, outPath):
        with open(inPath, "r") as f:
            data = f.readlines()
        with open(outPath, "w+") as f:
            for d in data:
                if d[0] == '-':
                    f.write("\t\ts_axis_fir_tdata <= -16'd{}; #2;\n".format(d[1:].strip()))
                else:
                    f.write("\t\ts_axis_fir_tdata <= 16'd{}; #2;\n".format(d.strip()))
        
                
    def convert2hex(self, inPath, outPath):
        with open(inPath, "r") as f:
            data = f.readlines()
        hexData = ["0x{:X}".format(int(i)).split('x')[-1] for i in data]
        with open(outPath, "w+") as f:
            for i in hexData:
                f.write(i)
                f.write("\n")
    def genLUT(self, inPath, outPath):
        with open(inPath, "r") as f:
            data = f.readlines()
        with open(outPath, "w+") as f:
            for i,d in enumerate(data):
                if d[0] == '-':
                    f.write("\t\tsignal[{}]= -16'd{};\n".format(i, d[1:].strip()))
                else:
                    f.write("\t\tsignal[{}]= 16'd{};\n".format(i, d.strip()))
    '''
    inputs: 
        inPath: path to a txt file of large, hard to look at values. 
        numBits: lenght of the binary string
        outPath: path to output file
        BinaryBase: True if the base of the input is binary
    outputs: a new text fil, where each line contains a binary string, 
    where every 4 digits sepearated by a space.
    '''
    def prettyFormatBinaryStrings( self, inPath, outPath, inputBase, length):
        with open(inPath, "r") as f:
            data = f.readlines()
        with open(outPath, "w+") as f:
            for binString in data:
                f.write(self._prettyFormatBinaryString(binString.strip(),inputBase, length ) + "\n")
            
    def _prettyFormatBinaryString( self, string, inputBase, length):
        assert length % 4 == 0, "length of string must be a mult. of 4"
        prettyBinaryString = ""
        if inputBase == 2:
            
            for i in range(0,(len(string)),4):
                prettyBinaryString += string[i:i+4] + " "
            return prettyBinaryString
        else:
            DecValue = int(string, inputBase)
            BinaryString = bin(DecValue if DecValue>0 else DecValue+(1<<length))
            BinaryString = BinaryString[2:]
            
            if DecValue >0 : 
                BinaryString = BinaryString.zfill(length)  
            
            for i in range(0,(len(BinaryString)),4):
                prettyBinaryString += BinaryString[i:i+4] + " "
            return prettyBinaryString
        
if __name__ == "__main__":
    F = GenFIRCode(168, "coeffs.txt", "out0.txt")
    #F.genTestBench("TenthInput.txt", "FIR_tb_samples")
    #F.convert2hex("TenthOutput.txt", "TenthOutputHex.txt")
    F.genLUT("TenthInput.txt", "sigLUT.txt")
    F.prettyFormatBinaryStrings("TenthOutput.txt", "TenthOutputBin_pretty.txt", 10, 40)
'''
  Taps = genDeclaration("wire", 16, "tap", 168)
  Buffs = genDeclaration("reg", 16, "buff", 168, signed = True)
'''
  